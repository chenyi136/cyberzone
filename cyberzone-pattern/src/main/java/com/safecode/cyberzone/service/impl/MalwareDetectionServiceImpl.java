package com.safecode.cyberzone.service.impl;

import com.safecode.cyberzone.base.dto.ResponseData;
import com.safecode.cyberzone.base.support.Code;
import com.safecode.cyberzone.controller.MalwareDetectionController;
import com.safecode.cyberzone.entity.*;
import com.safecode.cyberzone.global.consts.MaliceCheckConst;
import com.safecode.cyberzone.mapper.*;
import com.safecode.cyberzone.service.MalwareDetectionService;
import com.safecode.cyberzone.utils.FileUtil;
import com.safecode.cyberzone.utils.UUIDUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.*;
import java.util.Date;
import java.util.List;

@Transactional
@Service
public class MalwareDetectionServiceImpl implements MalwareDetectionService {

    @Autowired
    private MalwareCodeMapper malwareCodeMapper;

    @Autowired
    private MalwareMsgMapper malwareMsgMapper;

    @Autowired
    private MalwarePositionMapper malwarePositionMapper;

    @Autowired
    private MalwareWrongMsgMapper malwareWrongMsgMapper;

    @Autowired
    private VulnerabilityCnvdMapper vulnerabilityCnvdMapper;

    @Value("${wrongFile.wrongFilePath}")
    private String wrongFilePath;

    private static Logger log = LoggerFactory.getLogger(MalwareDetectionController.class);

    @Override
    public ResponseData<List<MalwareMsg>> check(String yara, List<String> rules, List<String> fileNames, String yaraOrder, Integer wasDelFiles) throws Exception {
        ResponseData<List<MalwareMsg>> commonJsonResponse = new ResponseData<>();
        commonJsonResponse.setCode(Code.OK.value());
        //拼接命令字符串
        StringBuffer commoned = new StringBuffer();

        //拼接规则路径
        for (int i = 0; i < rules.size(); i++) {
            String exeStr = rules.get(i);
            if (i == 0) {
                commoned.append(yara);
            }
            commoned.append(MaliceCheckConst.SPACEBAR + exeStr);

        }

        //拼接目标文件或目标文件夹
        for (int i = 0; i < fileNames.size(); i++) {
            String fileName = fileNames.get(i);
            commoned.append(MaliceCheckConst.SPACEBAR + fileName);
            if (i == fileNames.size() - 1) {
                commoned.append(MaliceCheckConst.SPACEBAR + yaraOrder);
            }
        }

        Process process = null;
        BufferedReader input = null;
        BufferedReader inputError = null;
        List<MalwareMsg> maliceMsgList = null;
        String user = "";
        try {
            Runtime runtime = Runtime.getRuntime();
            //记录yara命令
            log.info("执行的yara命令为：" + commoned.toString());
            System.out.println(commoned.toString());
            //执行yara命令
            process = runtime.exec(commoned.toString());
            //调用等待方法，指导process返回
            process.waitFor();
            //获得执行命令行命令返回的结果标识，如果返回0代表执行成功，返回1代表执行失败
            int i = process.exitValue();

            //保存一条检测申请
            MalwareCode maliceCode = new MalwareCode();
            maliceCode.setId(UUIDUtils.getUUID());
            maliceCode.setCreateTime(new Date());
            this.malwareCodeMapper.addMalwareCode(maliceCode);

            if (i != 0) {
                //获得错误的命令结果流
                inputError = new BufferedReader(new InputStreamReader(process.getErrorStream(), "UTF-8"));
                InputStream errorStream = process.getErrorStream();

                String s = UUIDUtils.getRandomForTime();
                String filePath = wrongFilePath + "/" + s + MaliceCheckConst.MSG_WRONG_FILE_SUFFIX;

                //保存错误的命令结果到服务器目录下
                this.saveErrorCommand(filePath, errorStream);
                MalwareWrongMsg maliceWrongMsg = new MalwareWrongMsg();
                maliceWrongMsg.setId(UUIDUtils.getUUID());
                maliceWrongMsg.setFileName(s + MaliceCheckConst.MSG_WRONG_FILE_SUFFIX);
                maliceWrongMsg.setFilePath(filePath);
                maliceWrongMsg.setSuffix(MaliceCheckConst.MSG_WRONG_FILE_SUFFIX);
                maliceWrongMsg.setCodeId(maliceCode.getId());
                maliceWrongMsg.setCreateTime(new Date());
                this.malwareWrongMsgMapper.addMalwareWrongMsg(maliceWrongMsg);
                log.error("命令执行错误，命令为：" + commoned.toString() + ";错误结果存储的文件路径为：" + filePath);
                commonJsonResponse.setMsg("命令执行错误");
                commonJsonResponse.setCode(Code.INTERNAL_SERVER_ERROR.value());
                return commonJsonResponse;
            }

            //获得正确的文件输出流
            input = new BufferedReader(new InputStreamReader(process.getInputStream()));
            StringBuffer rulestr = new StringBuffer();
            //Boolean wasOneRule = false;
            int a = 0;

            //保存命令结果信息
            this.saveYaraCommandResult(input, fileNames, maliceCode);
            //查询威胁信息表
            String id = maliceCode.getId();
            maliceMsgList = this.malwareMsgMapper.findMalwareMsgsByCodeId(id);

            if (maliceMsgList != null && maliceMsgList.size() > 0) {

                for (int m = 0; m < maliceMsgList.size(); m++) {

                    MalwareMsg msg = maliceMsgList.get(m);
                    if (!StringUtils.isBlank(msg.getRef())) {
                        try {
                            //查询威胁情报库的信息
                            List<VulnerabilityCnvd> vulnerabilityCnvds = this.vulnerabilityCnvdMapper.findVulnerabilityCnvdsByCveNumber(msg.getRef());
                            //返回从威胁情报库查到的中文描述
                            if (vulnerabilityCnvds != null && vulnerabilityCnvds.size() > 0) {
                                maliceMsgList.get(m).setDescription(vulnerabilityCnvds.get(0).getTitle());
                            }
                        } catch (Exception e) {

                        }
                    }
                    //根据威胁信息表的id查询威胁项的列表
                    List<MalwarePosition> malicePositions = this.malwarePositionMapper.findMalwarePositionByMsgId(msg.getId());
                    if (malicePositions != null && malicePositions.size() > 0) {
                        msg.setMalicePositions(malicePositions);
                    }
                }
            } else {
                commonJsonResponse.setMsg("检测完毕，没有发现恶意代码");
            }

            //如果wasDelFIles是1的话，说明yara要检验的是压缩文件，就需要将解压后的文件夹给删除掉
            if (wasDelFiles.equals(MaliceCheckConst.WASDELFILES_YES)) {
                FileUtil.deleteDirectory(fileNames.get(0));
            }

            if (input != null) {
                input.close();
            }
            if (inputError != null) {
                inputError.close();
            }
            commonJsonResponse.setData(maliceMsgList);
            return commonJsonResponse;
        } catch (Exception e) {
            e.printStackTrace();
            commonJsonResponse.setCode(Code.INTERNAL_SERVER_ERROR.value());
            throw e;
        }


    }

    /**
     * @param input      yara命令返回的结果流
     * @param fileNames  目标文件或目标文件夹
     * @param maliceCode 恶意代码对象
     * @throws IOException
     * @author xuq
     * @date 2019.1.1
     */
    private void saveYaraCommandResult(BufferedReader input, List<String> fileNames, MalwareCode maliceCode) throws IOException {
        MalwareMsg maliceMsg = null;
        a:
        while (true) {
            //读取返回的命令行结果的每一行
            String lineStr = input.readLine();
            if (lineStr == null) {
                break a;
            }
            //判断是不是规则的描述信息，描述信息包括author,reference,ref等
            if (lineStr.indexOf(MaliceCheckConst.SIGN_MIDDLE_LEFT) != -1 &&
                    lineStr.indexOf(MaliceCheckConst.SIGN_MIDDLE_RIGHT) != -1) {

                c:
                for (String commonStr : fileNames) {
                    //如果该行结果包含目标文件路径，说明是规则的描述信息
                    if (lineStr.indexOf(commonStr) != -1) {

                        //qie ge
                        maliceMsg = new MalwareMsg();
                        String ruleName = lineStr.substring(0, lineStr.indexOf(MaliceCheckConst.SIGN_MIDDLE_LEFT) - 1);
                        maliceMsg.setRuleName(ruleName);

                        String meta = lineStr.substring(lineStr.indexOf(MaliceCheckConst.SIGN_MIDDLE_LEFT) + 1, lineStr.lastIndexOf(MaliceCheckConst.SIGN_MIDDLE_RIGHT));
                        String[] metaList = meta.split(",");

                        for (String me : metaList) {

                            String[] meMap = me.split("=");
                            String mapKey = meMap[0];
                            String mapValue = meMap[1].replaceAll(MaliceCheckConst.MSG_STR, "");//去掉前后的“”
                            switch (mapKey) {
                                case MaliceCheckConst.MSG_AUTHOR:
                                    maliceMsg.setAuthor(mapValue);
                                    break;
                                case MaliceCheckConst.MSG_REFERENCE:
                                    maliceMsg.setReference(mapValue);
                                    break;
                                case MaliceCheckConst.MSG_WEIGHT:
                                    maliceMsg.setWeight(mapValue);
                                    break;
                                case MaliceCheckConst.MSG_VERSION:
                                    maliceMsg.setVersion(mapValue);
                                    break;
                                case MaliceCheckConst.MSG_DESCRIPTION:
                                    maliceMsg.setDescription(mapValue);
                                    break;
                                case MaliceCheckConst.MSG_REF:
                                    maliceMsg.setRef(mapValue);
                                    break;

                            }
                        }
                        String fileNameStr = lineStr.substring(lineStr.lastIndexOf(MaliceCheckConst.SIGN_MIDDLE_RIGHT) + 1);
                        String fileName = fileNameStr.substring(fileNameStr.lastIndexOf("/") + 1);
                        maliceMsg.setFileName(fileName);
                        maliceMsg.setCodeId(maliceCode.getId());
                        maliceMsg.setCreateTime(new Date());
                        maliceMsg.setId(UUIDUtils.getUUID());
                        this.malwareMsgMapper.addMalwareMsg(maliceMsg);
                        break c;
                    }

                }
                //说明是规则的描述信息，直接进行下一次的检测（这样判断有很小很小的概率出现，当检测的结果中同时包含“【”，“】”这种字符串，就直接跳过，不进行结果记录了）
                continue;
            }

            //yara的命中结果字符串
            if (maliceMsg != null) {
                String[] msgList = lineStr.split(":");
                String msgs = "";
                MalwarePosition malicePosition = new MalwarePosition();
                for (int j = 0; j < msgList.length; j++) {
                    String str = msgList[j].trim();
                    malicePosition.setId(UUIDUtils.getUUID());
                    malicePosition.setMsgId(maliceMsg.getId());
                    switch (j) {
                        case 0:
                            malicePosition.setBlobScale(str);
                            break;
                        case 1:
                            malicePosition.setVariable(str);
                            break;
                        case 2:
                            malicePosition.setContent(str);
                            break;
                    }
                }
                malicePosition.setCreateTime(new Date());
                this.malwarePositionMapper.addMalwarePosition(malicePosition);
            }
        }
    }

    /**
     * @param filePath    错误命令存储的服务器文件地址
     * @param errorStream yara返回的错误结果流
     * @throws IOException
     */
    public void saveErrorCommand(String filePath, InputStream errorStream) throws IOException {
        File targetFile = new File(filePath);
        if (!targetFile.getParentFile().exists()) {
            targetFile.getParentFile().mkdirs();
        }
        // 创建文件输入流对象
        FileOutputStream out = new FileOutputStream(targetFile);
        int n = 1024;
        byte buffer[] = new byte[n];
        // 读取输入流
        while ((errorStream.read(buffer, 0, n) != -1) && (n > 0)) {
            out.write(buffer, 0, buffer.length);
        }
        errorStream.close();
        out.close();//关流
    }
}
