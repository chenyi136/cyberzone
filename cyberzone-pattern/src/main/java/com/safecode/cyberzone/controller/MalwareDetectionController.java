package com.safecode.cyberzone.controller;

import com.safecode.cyberzone.base.dto.ResponseData;
import com.safecode.cyberzone.base.pojo.FileInfo;
import com.safecode.cyberzone.base.support.Code;
import com.safecode.cyberzone.global.consts.MaliceCheckConst;
import com.safecode.cyberzone.entity.MalwareMsg;
import com.safecode.cyberzone.entity.YaraRule;
import com.safecode.cyberzone.service.MalwareDetectionService;
import com.safecode.cyberzone.service.YaraRuleService;
import com.safecode.cyberzone.utils.CompressedFileUtils;
import com.safecode.cyberzone.utils.FileUtil;
import com.safecode.cyberzone.utils.UUIDUtils;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.apache.commons.compress.utils.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.stereotype.Controller;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

//@CrossOrigin
@Controller
@PropertySource(value = "classpath:malwareDetection.properties", encoding = "utf-8")
@RequestMapping(value = "api/v1/malwaredetection")
@Api(description = "恶意代码审查")

/**
 * @author xuq
 * @data 2018.12.10
 */
public class MalwareDetectionController {


    @Autowired
    private MalwareDetectionService malwareDetectionService;

    @Autowired
    private YaraRuleService yaraRuleService;

    @Value("${uploadFile.savePath}")
    public String savePath;

    @Value("${yara.rulePath}")
    public String rulePath;

    private static Logger log = LoggerFactory.getLogger(MalwareDetectionController.class);

    @ApiOperation(value = "代码审查")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "upload", value = "文件名称", dataType = "file", required = false),
            @ApiImplicitParam(name = "filePath", value = "文件的服务器路径", dataType = "String", required = false),
            @ApiImplicitParam(name = "types", value = "规则类型的字符串集[以逗号分割的字符串]", dataType = "String", required = true),
    })

    @RequestMapping(value = "check", method = RequestMethod.POST)
    @ResponseBody
    public ResponseData<List<MalwareMsg>> check(HttpServletRequest request, HttpSession session, MultipartFile upload, YaraRule yaraRule, String filePath) throws Exception {

        ResponseData<List<MalwareMsg>> commonJsonResponse = new ResponseData<>();
        if (StringUtils.isEmpty(upload) || org.apache.commons.lang.StringUtils.isBlank(upload.getOriginalFilename())) {

            //如果既没有上传文件，又没有给服务器文件的路径，直接返回
            if (StringUtils.isEmpty(filePath)) {
                log.error("请上传文件或传递文件路径", request.getMethod(), request.getRequestURL().toString());
                commonJsonResponse.setCode(Code.INTERNAL_SERVER_ERROR.value());
                commonJsonResponse.setMsg("请上传文件或传递文件路径");
                return commonJsonResponse;
            }

            File file = new File(filePath);
            FileInputStream input = new FileInputStream(file);
            upload = new MockMultipartFile("file", file.getName(), "text/plain", IOUtils.toByteArray(input));
        }
        String filepathForTime = UUIDUtils.getRandomForTime();
        String path = savePath + "/" + filepathForTime;
        try {

            //拼接yara命令参数
            String yaraOrder = MaliceCheckConst.YAVA_PARAM_R + MaliceCheckConst.SPACEBAR + MaliceCheckConst.YAVA_PARAM_M + MaliceCheckConst.SPACEBAR + MaliceCheckConst.YAVA_PARAM_S;
            List<String> rulesPaths = null;
            String types = yaraRule.getTypes();
            String[] split = null;
            if (!StringUtils.isEmpty(types)) {
                split = types.split(",");
            }

            //根据types查询到所有的类型
            if (split != null && split.length > 0) {

                rulesPaths = this.yaraRuleService.findRulesByTypes(Arrays.asList(split));

            } else {
                rulesPaths = this.yaraRuleService.findRulesPaths(yaraRule);
            }
            FileInfo fileInfo = FileUtil.saveFile(upload, path);
            log.info("开始检测...文件路径为: " + fileInfo.getFilePath(), request.getMethod(), request.getRequestURL().toString());
            String fileName = fileInfo.getFileName();
            //String conpressSavePath = compressFileSavePath +"/"+filepathForTime;
            Integer wasDelFiles = null;
            List<String> fileNames = new ArrayList<>();
            //zip压缩包
            if (fileName.endsWith(MaliceCheckConst.MSG_COMPRESS_PACKAGE_ZIP)) {
                String conpressSavePath = CompressedFileUtils.unZipFiles(fileInfo.getFilePath());
                fileNames.add(conpressSavePath);
                wasDelFiles = 1;
                //tar.gz压缩包
            } else if (fileName.endsWith(MaliceCheckConst.MSG_COMPRESS_PACKAGE_GZ)) {
                String conpressSavePath = CompressedFileUtils.unGzFiles(fileInfo.getFilePath());
                fileNames.add(conpressSavePath);
                wasDelFiles = 1;
            } else {
                fileNames.add(fileInfo.getFilePath());
                wasDelFiles = 0;
            }

            commonJsonResponse = malwareDetectionService.check(MaliceCheckConst.YAVA, rulesPaths, fileNames, yaraOrder, wasDelFiles);
            log.info("检测完毕...文件路径为: " + fileInfo.getFilePath(), request.getMethod(), request.getRequestURL().toString());
            return commonJsonResponse;

        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }

    }

    @RequestMapping(value = "flushRule", method = RequestMethod.GET)
    @ResponseBody
    public ResponseData<List<YaraRule>> flushRule(HttpServletRequest request) {

        ResponseData<List<YaraRule>> commonJsonResponse = new ResponseData();

        File file = new File(rulePath);
        if (!file.exists()) {
            log.error("服务器规则目录不存在",request.getMethod(), request.getRequestURL().toString());
            commonJsonResponse.setMsg("服务器规则目录不存在");
            commonJsonResponse.setCode(Code.INTERNAL_SERVER_ERROR.value());
            return commonJsonResponse;
        }
        File[] files = file.listFiles();
        List<String> rules = new ArrayList<>();
        for (File f : files) {
            if (f.isDirectory()) {

            } else {
                //不要隐藏文件
                if (!f.getName().startsWith(".") && f.getName().endsWith(".yar")) {
                    rules.add(f.getAbsolutePath());
                }


            }
        }
        commonJsonResponse = this.yaraRuleService.flushRule(rules);
        return commonJsonResponse;
    }
}
