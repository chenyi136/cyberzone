package com.safecode.cyberzone.service.impl;

import java.io.InputStreamReader;
import java.sql.Connection;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;

import org.apache.commons.lang.StringUtils;
import org.apache.ibatis.jdbc.ScriptRunner;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.safecode.cyberzone.base.utils.DataUtil;
import com.safecode.cyberzone.mapper.VulnerabilityCnvdMapper;
import com.safecode.cyberzone.mapper.VulnerabilityNvdMapper;
import com.safecode.cyberzone.pojo.VulnerabilityCnvd;
import com.safecode.cyberzone.pojo.VulnerabilityNvd;
import com.safecode.cyberzone.service.VulnerabilityService;
import com.safecode.cyberzone.utils.HttpsUtils;
import com.safecode.cyberzone.vo.VulnerabilityCnvdVo;
import com.safecode.cyberzone.vo.VulnerabilityNvdVo;


@Service
@Transactional
@PropertySource(value = {"classpath:remote.properties"} , ignoreResourceNotFound = true)
public class VulnerabilityServiceImpl implements VulnerabilityService{
	@Autowired
	private DataSource dataSource;
	
	@Value("${cyberzone.sync.url}")
	private String syncUrl;
	
	@Value("${cyberzone.sync.orgCode}")
	private String orgCode;
	
	@Autowired
	private VulnerabilityNvdMapper nvdMapper;
	@Autowired
	private VulnerabilityCnvdMapper cnvdMapper; 
	
	@Override
	@Transactional(readOnly=false)
	/** 手动更新:导入sql文件,实现数据同步 */
	public void readSqlFile(MultipartFile sqlFile, HttpServletRequest request) throws Exception {
		if (sqlFile != null && !sqlFile.isEmpty() && StringUtils.isNotEmpty(sqlFile.getOriginalFilename())) {
			execSqlFileByMysql(sqlFile);
		}
	}
	
	@Override
	/** CNVD分页列表  */
	public PageInfo<VulnerabilityCnvd> queryPageList(VulnerabilityCnvdVo vulnerabilityCnvdVo) {
		Map<Object, Object> params = new HashMap<>();
		if (vulnerabilityCnvdVo == null || DataUtil.isEmpty(vulnerabilityCnvdVo.getPageNum())) {
            params.put("pageNum", 1);
        }else{
        	params.put("pageNum", vulnerabilityCnvdVo.getPageNum());
        }
        if (vulnerabilityCnvdVo == null || DataUtil.isEmpty(vulnerabilityCnvdVo.getPageSize())) {
            params.put("pageSize", 10);
        }else{
        	params.put("pageSize", vulnerabilityCnvdVo.getPageSize());
        }
		PageHelper.startPage(params);
		Page<VulnerabilityCnvd> page = cnvdMapper.queryPageList(vulnerabilityCnvdVo);
		return new PageInfo<VulnerabilityCnvd>(page);
	}
	
	@Override
	/** NVD分页列表 */
	public PageInfo<VulnerabilityNvd> queryNvdPageList(VulnerabilityNvdVo vulnerabilityNvdVo) {
		HashMap<Object, Object> params = new HashMap<>();
		if (vulnerabilityNvdVo == null || DataUtil.isEmpty(vulnerabilityNvdVo.getPageNum())) {
            params.put("pageNum", 1);
        }else{
        	params.put("pageNum", vulnerabilityNvdVo.getPageNum());
        }
        if (vulnerabilityNvdVo == null || DataUtil.isEmpty(vulnerabilityNvdVo.getPageSize())) {
            params.put("pageSize", 10);
        }else{
        	params.put("pageSize", vulnerabilityNvdVo.getPageSize());
        }
		PageHelper.startPage(params);
		Page<VulnerabilityNvd> page = nvdMapper.queryPageList(vulnerabilityNvdVo);
		return new PageInfo<VulnerabilityNvd>(page);
	}

	@Override
	/** CNVD详情,关联展示NVD */
	public Map<String, Object> queryById(String id) {
		Map<String, Object> bothMap = cnvdMapper.queryById(id);
		if(bothMap != null && bothMap.get("cnvd_productsXml") != null){
			String str = bothMap.get("cnvd_productsXml").toString();
			List<String> productList = new ArrayList<String>();
			if(StringUtils.isNotBlank(str)){
				str = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + str;
				Document doc = null;
				try {
					// 读取并解析XML文档,将字符串转为XML
					doc = DocumentHelper.parseText(str);
					Element rootElement = doc.getRootElement();
					List<Element> elements = rootElement.elements();
					for (Element element : elements) {
						String product = element.getStringValue();
						productList.add(product);
					}
				}catch (DocumentException e) {
					e.printStackTrace();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			bothMap.remove("cnvd_productsXml");
			bothMap.put("productList",productList);
		}
		return bothMap;
	}
	
	@Override
	/** 在线更新,参数最新更新时间和认证参数,获取最新数据同步至数据库*/
	public void autoSync() throws Exception {
		Map<String, Object> params = new HashMap<String, Object>();
		if(cnvdMapper.getLastUpdateTime()!= null && cnvdMapper.getLastUpdateTime().get("updateTime")!= null){
			Timestamp cnvdUpdateTime = (Timestamp) cnvdMapper.getLastUpdateTime().get("updateTime");
			params.put("cnvdUpdateTime", cnvdUpdateTime.toString());
		}
		if(nvdMapper.getLastUpdateTime() != null && nvdMapper.getLastUpdateTime().get("updateTime") != null){
			Timestamp nvdUpdateTime = (Timestamp) nvdMapper.getLastUpdateTime().get("updateTime");
			params.put("nvdUpdateTime", nvdUpdateTime.toString());
		}
		//添加认证 **********************需要确定参数以及参数值********************
		params.put("orgCode", orgCode);
		String doPost = HttpsUtils.doPost(syncUrl, params, null, "utf-8");
		JSONObject parse = (JSONObject) JSONObject.parse(doPost);
		if(parse != null){
			JSONObject data = (JSONObject) parse.get("data");
				if(data != null){
					Object objCnvdList = data.get("cnvdList");
					if(objCnvdList != null){
						List<VulnerabilityCnvd> cnvdList = JSON.parseArray(objCnvdList.toString(), VulnerabilityCnvd.class);
						for (VulnerabilityCnvd cnvd : cnvdList) {
							VulnerabilityCnvd oriCnvd = cnvdMapper.selectByPrimaryKey(cnvd.getId());
							if(oriCnvd != null){
								cnvdMapper.updateByPrimaryKey(cnvd);
							}else{
								cnvdMapper.insert(cnvd);
							}
						}
					}
					Object objnvdList =  data.get("nvdList");
					if(objnvdList != null){
						List<VulnerabilityNvd> nvdList = JSON.parseArray(objnvdList.toString(), VulnerabilityNvd.class);
						for (VulnerabilityNvd nvd : nvdList) {
							VulnerabilityNvd oriNvd = nvdMapper.selectByPrimaryKey(nvd.getId());
							if(oriNvd != null){
								nvdMapper.updateByPrimaryKey(nvd);
							}else{
								nvdMapper.insert(nvd);
							}
						}
					}
				}
		}
	}
	
	@Override
	/** 获取数据库CNVD最新的同步时间 */
	public Timestamp getCNVDLastUpdateTime() {
		Map<String, Object> map = cnvdMapper.getLastUpdateTime();
		Timestamp lastUpdateTime = null;
		if(map != null && map.get("updateTime") != null){
			lastUpdateTime = (Timestamp) map.get("updateTime");
		}
		return lastUpdateTime;
	}
	
	@Override
	/** 获取数据库NVD最新的同步时间 */
	public Timestamp getNVDLastUpdateTime() {
		Map<String, Object> map = nvdMapper.getLastUpdateTime();
		Timestamp lastUpdateTime = null;
		if(map != null && map.get("updateTime") != null){
			lastUpdateTime = (Timestamp) map.get("updateTime");
		}
		return lastUpdateTime;
	}
	
	private void execSqlFileByMysql(MultipartFile sqlFile) throws Exception {
        Exception error = null;
        Connection conn = null;
        try {
        	conn = dataSource.getConnection();
            //设置不自动提交
            conn.setAutoCommit(false);
            ScriptRunner runner = new ScriptRunner(conn);
            /* 设置不自动提交
             * runner.setAutoCommit(false);
             * setStopOnError参数作用：遇见错误是否停止；
             * （1）false，遇见错误不会停止，会继续执行，会打印异常信息，并不会抛出异常，当前方法无法捕捉异常无法进行回滚操作，无法保证在一个事务内执行；
             * （2）true，遇见错误会停止执行，打印并抛出异常，捕捉异常，并进行回滚，保证在一个事务内执行；
             */
            runner.setStopOnError(true);
            /* 按照那种方式执行
             * 		方式一：true则获取整个脚本并执行；
             * 		方式二：false则按照自定义的分隔符每行执行；
             */
            runner.setSendFullScript(false);
            //定义命令间的分隔符
            runner.setDelimiter(";");
            runner.setFullLineDelimiter(false);
            //设置是否输出日志，null不输出日志，不设置自动将日志输出到控制台
            runner.setLogWriter(null);
            //如果又多个sql文件，可以写多个runner.runScript(xxx),
            runner.runScript(new InputStreamReader(sqlFile.getInputStream(), "utf-8"));
            conn.commit();
        } catch (Exception e) {
            conn.rollback();
            error = e;
        } finally {
            close(conn);
        }
        if (error != null) {
            throw error;
        }
    }
    private void close(Connection conn) {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (Exception e) {
            if (conn != null) {
                conn = null;
            }
        }
    }
	
	@Override
	/**获取威胁情报库的威胁等级及数量(威胁情报库首页的威胁等级)*/
	public List<Map<String, Object>> getBugCountByServerity() {
		return cnvdMapper.getBugCountByServerity();
	}

	@Override
	/**按年度获取威胁数量(威胁情报库首页的时间趋势图)*/
	public List<Map<String, Object>> getBugCountByYear() {
		return cnvdMapper.getBugCountByYear();
	}

	@Override
	/**按时间倒序获取10条数据(威胁情报库首页的重点新闻)*/
	public List<VulnerabilityCnvd> getKeyNews() {
		return cnvdMapper.getKeyNews();
	}

	@Override
	/**获取威胁情报的类别及数量(威胁情报库首页的情报类别)*/
	public List<Map<String, Object>> getBugCountByClassify() {
		return cnvdMapper.getBugCountByClassify();
	}

	
}
